{
  "address": "0x687C28554335E11A007772a0A87BF354cfd1d87f",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "terms",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "gasLimit",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Transaction",
          "name": "transaction",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "delegationHash",
          "type": "bytes32"
        }
      ],
      "name": "enforceCaveat",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xe8f79a0bdce60b38a755c15deb287b1f843ac2c62143ae46e409d6e79910dc0d",
  "receipt": {
    "to": null,
    "from": "0xDdb18b319BE3530560eECFF962032dFAD88212d4",
    "contractAddress": "0x687C28554335E11A007772a0A87BF354cfd1d87f",
    "transactionIndex": 145,
    "gasUsed": "216200",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2e203fb1886d4f34807caa165998905a9edfd4c421ec03dd3e4cce18d6348ce6",
    "transactionHash": "0xe8f79a0bdce60b38a755c15deb287b1f843ac2c62143ae46e409d6e79910dc0d",
    "logs": [],
    "blockNumber": 15386884,
    "cumulativeGasUsed": "17260914",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "9434a8c86af30d9c166c7025f6db4f22",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"terms\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Transaction\",\"name\":\"transaction\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"delegationHash\",\"type\":\"bytes32\"}],\"name\":\"enforceCaveat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/enforcers/AllowedMethodsEnforcer.sol\":\"AllowedMethodsEnforcer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/CaveatEnforcer.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport \\\"./TypesAndDecoders.sol\\\";\\n\\nabstract contract CaveatEnforcer {\\n    function enforceCaveat(\\n        bytes calldata terms,\\n        Transaction calldata tx,\\n        bytes32 delegationHash\\n    ) public virtual returns (bool);\\n}\\n\",\"keccak256\":\"0x14ec17bfb3cc94c4a0a81bbddf681150be2b574176294cee3c6fb21ab0f62fa3\",\"license\":\"MIT\"},\"contracts/TypesAndDecoders.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\nimport \\\"./libraries/ECRecovery.sol\\\";\\n\\n// BEGIN EIP712 AUTOGENERATED SETUP\\nstruct EIP712Domain {\\n    string name;\\n    string version;\\n    uint256 chainId;\\n    address verifyingContract;\\n}\\n\\nbytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\\n    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n);\\n\\nstruct Invocation {\\n    Transaction transaction;\\n    SignedDelegation[] authority;\\n}\\n\\nbytes32 constant INVOCATION_TYPEHASH = keccak256(\\n    \\\"Invocation(Transaction transaction,SignedDelegation[] authority)Caveat(address enforcer,bytes terms)Delegation(address delegate,bytes32 authority,Caveat[] caveats)SignedDelegation(Delegation delegation,bytes signature)Transaction(address to,uint256 gasLimit,bytes data)\\\"\\n);\\n\\nstruct Invocations {\\n    Invocation[] batch;\\n    ReplayProtection replayProtection;\\n}\\n\\nbytes32 constant INVOCATIONS_TYPEHASH = keccak256(\\n    \\\"Invocations(Invocation[] batch,ReplayProtection replayProtection)Caveat(address enforcer,bytes terms)Delegation(address delegate,bytes32 authority,Caveat[] caveats)Invocation(Transaction transaction,SignedDelegation[] authority)ReplayProtection(uint nonce,uint queue)SignedDelegation(Delegation delegation,bytes signature)Transaction(address to,uint256 gasLimit,bytes data)\\\"\\n);\\n\\nstruct SignedInvocation {\\n    Invocations invocations;\\n    bytes signature;\\n}\\n\\nbytes32 constant SIGNEDINVOCATION_TYPEHASH = keccak256(\\n    \\\"SignedInvocation(Invocations invocations,bytes signature)Caveat(address enforcer,bytes terms)Delegation(address delegate,bytes32 authority,Caveat[] caveats)Invocation(Transaction transaction,SignedDelegation[] authority)Invocations(Invocation[] batch,ReplayProtection replayProtection)ReplayProtection(uint nonce,uint queue)SignedDelegation(Delegation delegation,bytes signature)Transaction(address to,uint256 gasLimit,bytes data)\\\"\\n);\\n\\nstruct Transaction {\\n    address to;\\n    uint256 gasLimit;\\n    bytes data;\\n}\\n\\nbytes32 constant TRANSACTION_TYPEHASH = keccak256(\\n    \\\"Transaction(address to,uint256 gasLimit,bytes data)\\\"\\n);\\n\\nstruct ReplayProtection {\\n    uint256 nonce;\\n    uint256 queue;\\n}\\n\\nbytes32 constant REPLAYPROTECTION_TYPEHASH = keccak256(\\n    \\\"ReplayProtection(uint nonce,uint queue)\\\"\\n);\\n\\nstruct Delegation {\\n    address delegate;\\n    bytes32 authority;\\n    Caveat[] caveats;\\n}\\n\\nbytes32 constant DELEGATION_TYPEHASH = keccak256(\\n    \\\"Delegation(address delegate,bytes32 authority,Caveat[] caveats)Caveat(address enforcer,bytes terms)\\\"\\n);\\n\\nstruct Caveat {\\n    address enforcer;\\n    bytes terms;\\n}\\n\\nbytes32 constant CAVEAT_TYPEHASH = keccak256(\\n    \\\"Caveat(address enforcer,bytes terms)\\\"\\n);\\n\\nstruct SignedDelegation {\\n    Delegation delegation;\\n    bytes signature;\\n}\\n\\nbytes32 constant SIGNEDDELEGATION_TYPEHASH = keccak256(\\n    \\\"SignedDelegation(Delegation delegation,bytes signature)Caveat(address enforcer,bytes terms)Delegation(address delegate,bytes32 authority,Caveat[] caveats)\\\"\\n);\\n\\n// END EIP712 AUTOGENERATED SETUP\\n\\ncontract EIP712Decoder is ECRecovery {\\n    // BEGIN EIP712 AUTOGENERATED BODY. See scripts/typesToCode.js\\n\\n    // function GET_EIP712DOMAIN_PACKETHASH(EIP712Domain memory _input)\\n    //     public\\n    //     pure\\n    //     returns (bytes32)\\n    // {\\n    //     bytes memory encoded = abi.encode(\\n    //         EIP712DOMAIN_TYPEHASH,\\n    //         _input.name,\\n    //         _input.version,\\n    //         _input.chainId,\\n    //         _input.verifyingContract\\n    //     );\\n\\n    //     return keccak256(encoded);\\n    // }\\n\\n    function GET_INVOCATION_PACKETHASH(Invocation memory _input)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory encoded = abi.encode(\\n            INVOCATION_TYPEHASH,\\n            GET_TRANSACTION_PACKETHASH(_input.transaction),\\n            GET_SIGNEDDELEGATION_ARRAY_PACKETHASH(_input.authority)\\n        );\\n\\n        return keccak256(encoded);\\n    }\\n\\n    function GET_SIGNEDDELEGATION_ARRAY_PACKETHASH(\\n        SignedDelegation[] memory _input\\n    ) public pure returns (bytes32) {\\n        bytes memory encoded;\\n        for (uint256 i = 0; i < _input.length; i++) {\\n            encoded = bytes.concat(\\n                encoded,\\n                GET_SIGNEDDELEGATION_PACKETHASH(_input[i])\\n            );\\n        }\\n\\n        bytes32 hash = keccak256(encoded);\\n        return hash;\\n    }\\n\\n    function GET_INVOCATIONS_PACKETHASH(Invocations memory _input)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory encoded = abi.encode(\\n            INVOCATIONS_TYPEHASH,\\n            GET_INVOCATION_ARRAY_PACKETHASH(_input.batch),\\n            GET_REPLAYPROTECTION_PACKETHASH(_input.replayProtection)\\n        );\\n\\n        return keccak256(encoded);\\n    }\\n\\n    function GET_INVOCATION_ARRAY_PACKETHASH(Invocation[] memory _input)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory encoded;\\n        for (uint256 i = 0; i < _input.length; i++) {\\n            encoded = bytes.concat(\\n                encoded,\\n                GET_INVOCATION_PACKETHASH(_input[i])\\n            );\\n        }\\n\\n        bytes32 hash = keccak256(encoded);\\n        return hash;\\n    }\\n\\n    // function GET_SIGNEDINVOCATION_PACKETHASH(SignedInvocation memory _input)\\n    //     public\\n    //     pure\\n    //     returns (bytes32)\\n    // {\\n    //     bytes memory encoded = abi.encode(\\n    //         SIGNEDINVOCATION_TYPEHASH,\\n    //         GET_INVOCATIONS_PACKETHASH(_input.invocations),\\n    //         keccak256(_input.signature)\\n    //     );\\n\\n    //     return keccak256(encoded);\\n    // }\\n\\n    function GET_TRANSACTION_PACKETHASH(Transaction memory _input)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory encoded = abi.encode(\\n            TRANSACTION_TYPEHASH,\\n            _input.to,\\n            _input.gasLimit,\\n            keccak256(_input.data)\\n        );\\n\\n        return keccak256(encoded);\\n    }\\n\\n    function GET_REPLAYPROTECTION_PACKETHASH(ReplayProtection memory _input)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory encoded = abi.encode(\\n            REPLAYPROTECTION_TYPEHASH,\\n            _input.nonce,\\n            _input.queue\\n        );\\n\\n        return keccak256(encoded);\\n    }\\n\\n    function GET_DELEGATION_PACKETHASH(Delegation memory _input)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory encoded = abi.encode(\\n            DELEGATION_TYPEHASH,\\n            _input.delegate,\\n            _input.authority,\\n            GET_CAVEAT_ARRAY_PACKETHASH(_input.caveats)\\n        );\\n\\n        return keccak256(encoded);\\n    }\\n\\n    function GET_CAVEAT_ARRAY_PACKETHASH(Caveat[] memory _input)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory encoded;\\n        for (uint256 i = 0; i < _input.length; i++) {\\n            encoded = bytes.concat(encoded, GET_CAVEAT_PACKETHASH(_input[i]));\\n        }\\n\\n        bytes32 hash = keccak256(encoded);\\n        return hash;\\n    }\\n\\n    function GET_CAVEAT_PACKETHASH(Caveat memory _input)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory encoded = abi.encode(\\n            CAVEAT_TYPEHASH,\\n            _input.enforcer,\\n            keccak256(_input.terms)\\n        );\\n\\n        return keccak256(encoded);\\n    }\\n\\n    function GET_SIGNEDDELEGATION_PACKETHASH(SignedDelegation memory _input)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory encoded = abi.encode(\\n            SIGNEDDELEGATION_TYPEHASH,\\n            GET_DELEGATION_PACKETHASH(_input.delegation),\\n            keccak256(_input.signature)\\n        );\\n\\n        return keccak256(encoded);\\n    }\\n}\\n\",\"keccak256\":\"0x62c25b5d5fd7e3390c184c776b29a08a4c3b9859efc54483114e6e8c817b4cfa\",\"license\":\"MIT\"},\"contracts/enforcers/AllowedMethodsEnforcer.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport \\\"../CaveatEnforcer.sol\\\";\\n\\ncontract AllowedMethodsEnforcer is CaveatEnforcer {\\n    function enforceCaveat(\\n        bytes calldata terms,\\n        Transaction calldata transaction,\\n        bytes32 delegationHash\\n    ) public pure override returns (bool) {\\n        bytes4 targetSig = bytes4(transaction.data[0:4]);\\n        for (uint256 i = 0; i < terms.length; i += 4) {\\n            bytes4 allowedSig = bytes4(terms[i:i + 4]);\\n            if (allowedSig == targetSig) {\\n                return true;\\n            }\\n        }\\n        revert(\\\"AllowedMethodsEnforcer:method-not-allowed\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xfe08ca70e9ae0c1e3efa201c4a5f5bcec9c3021ce121259662f2188a207a029b\",\"license\":\"MIT\"},\"contracts/libraries/ECRecovery.sol\":{\"content\":\"pragma solidity 0.8.15;\\n\\n// SPDX-License-Identifier: MIT\\n\\ncontract ECRecovery {\\n    /**\\n     * @dev Recover signer address from a message by using their signature\\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\\n     */\\n    function recover(bytes32 hash, bytes memory sig)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        //Check the signature length\\n        if (sig.length != 65) {\\n            return (address(0));\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\\n        if (v < 27) {\\n            v += 27;\\n        }\\n\\n        // If the version is correct return the signer address\\n        if (v != 27 && v != 28) {\\n            return (address(0));\\n        } else {\\n            return ecrecover(hash, v, r, s);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdcd8b97fb382a5e43e7a9000515dfad14263e8ab7f548b276b5952e7970fee03\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506102f3806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80635068de4c14610030575b600080fd5b61004361003e36600461014e565b610057565b604051901515815260200160405180910390f35b60008061006760408501856101ef565b6100769160049160009161023d565b61007f91610267565b905060005b858110156100e757600087828861009c826004610297565b926100a99392919061023d565b6100b291610267565b90506001600160e01b0319808416908216036100d45760019350505050610146565b506100e0600482610297565b9050610084565b5060405162461bcd60e51b815260206004820152602960248201527f416c6c6f7765644d6574686f6473456e666f726365723a6d6574686f642d6e6f6044820152681d0b585b1b1bddd95960ba1b606482015260840160405180910390fd5b949350505050565b6000806000806060858703121561016457600080fd5b843567ffffffffffffffff8082111561017c57600080fd5b818701915087601f83011261019057600080fd5b81358181111561019f57600080fd5b8860208285010111156101b157600080fd5b6020928301965094509086013590808211156101cc57600080fd5b508501606081880312156101df57600080fd5b9396929550929360400135925050565b6000808335601e1984360301811261020657600080fd5b83018035915067ffffffffffffffff82111561022157600080fd5b60200191503681900382131561023657600080fd5b9250929050565b6000808585111561024d57600080fd5b8386111561025a57600080fd5b5050820193919092039150565b6001600160e01b0319813581811691600485101561028f5780818660040360031b1b83161692505b505092915050565b600082198211156102b857634e487b7160e01b600052601160045260246000fd5b50019056fea2646970667358221220231dec30f5347ff17e9e6ce1e3a6c3bc4893f360622799a8abf4c872ebdbca5d64736f6c634300080f0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80635068de4c14610030575b600080fd5b61004361003e36600461014e565b610057565b604051901515815260200160405180910390f35b60008061006760408501856101ef565b6100769160049160009161023d565b61007f91610267565b905060005b858110156100e757600087828861009c826004610297565b926100a99392919061023d565b6100b291610267565b90506001600160e01b0319808416908216036100d45760019350505050610146565b506100e0600482610297565b9050610084565b5060405162461bcd60e51b815260206004820152602960248201527f416c6c6f7765644d6574686f6473456e666f726365723a6d6574686f642d6e6f6044820152681d0b585b1b1bddd95960ba1b606482015260840160405180910390fd5b949350505050565b6000806000806060858703121561016457600080fd5b843567ffffffffffffffff8082111561017c57600080fd5b818701915087601f83011261019057600080fd5b81358181111561019f57600080fd5b8860208285010111156101b157600080fd5b6020928301965094509086013590808211156101cc57600080fd5b508501606081880312156101df57600080fd5b9396929550929360400135925050565b6000808335601e1984360301811261020657600080fd5b83018035915067ffffffffffffffff82111561022157600080fd5b60200191503681900382131561023657600080fd5b9250929050565b6000808585111561024d57600080fd5b8386111561025a57600080fd5b5050820193919092039150565b6001600160e01b0319813581811691600485101561028f5780818660040360031b1b83161692505b505092915050565b600082198211156102b857634e487b7160e01b600052601160045260246000fd5b50019056fea2646970667358221220231dec30f5347ff17e9e6ce1e3a6c3bc4893f360622799a8abf4c872ebdbca5d64736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}